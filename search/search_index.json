{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Pineapple Language \u00b6 Pineapple is a programming language designed for humans. It aims to reduces WTFs from programmers. Write clean code easily without frying your brain. Create beautiful and elegant API without hacking. Let others understand what you wrote. No more object-orientated programming. Say good bye to debugging hell. What you see is what you get. Say Hello to Pineapple.","title":"The Pineapple Language"},{"location":"#the-pineapple-language","text":"Pineapple is a programming language designed for humans. It aims to reduces WTFs from programmers. Write clean code easily without frying your brain. Create beautiful and elegant API without hacking. Let others understand what you wrote. No more object-orientated programming. Say good bye to debugging hell. What you see is what you get. Say Hello to Pineapple.","title":"The Pineapple Language"},{"location":"001-motivation/","text":"What is this page about? After reading this page, you will understand why Pineapple is born, and what kind of problems it aims to tackle. Introduction \u00b6 In any software project, the most expensive cost is actually not the development, but the maintenance, with some citing as high as 75% of the resources actually went into maintenance. 1 2 3 4 According to the author of Clean Code, Uncle Bob, the main reason that causes software maintenance to be expensive is due to poorly written code . 5 Although the main culprit of dirty codes are programmers, I believe that the other reason might be due to the programming language itself. In fact, most programming languages such as Java, Python, Javascript, Ruby, C/C++ and PHP etc. have the following problem: Hard to write clean code. To write clean code in those languages, oftentimes you need to adhere to some military discipline or zen philosophy, or else you might shoot yourself in the foot. So, this is why Pineapple is created, it is here to solve the difficulties in writing clean code . In other words, Pineapple is here to reduce the WTFs from developers. Factors that promoted dirty code \u00b6 In summary, the primary factors that promoted dirty code are: Hard to create understandable functions Too many ways to create functions Hard to extend existing classes Dynamic typing Implicit mutability Note Factor 4 and Factor 5 will not be discussed here as they are already discussed thoroughly by others. 6 7 Hard to create understandable functions \u00b6 The main reason that prevented programmers to create understandble functions easily is that most programming languages still bares similarity with Assembly Code. # Assembly MOV A , B # Python send ( a , b ) From the code above, we can see that both Assembly and Python does not differ much. They both have the following characteristics: function name comes before arguments (a.k.a. prefix-oriented) arguments position are ambiguous to understand what the function means, one usually have to lookup for its definition In short, it is unnatural. Because we don't speak in such manner. In general, all our instructive sentences have the following structure: <subject> | <verb> | <object> | <preposition> | <object> For example: <subject> | <verb> | <object> | <preposition> | <object> John, | bring | the apple | to | kitchen. There are several ways to emulate the sentence above in programming languages, but none of them are as clear and concise as the English sentence. # procedural bring ( john , apple , kitchen ) # object-oriented john . bring ( apple , kitchen ) # name parameters bring ( person = john , food = apple , destination = kitchen ) That's why sometimes, no matter how much you cook your brain juice, you just can't figure out a name that is good enough for your function. Solution \u00b6 The solution to this problem is mixfix function . Mixfix means that the name of the function can be separated into many parts. For example: // Pineapple john . bring ( apple to kitchen ) In this case, the names of the function is bring..to . Facts Some programming languages like Smalltalk and Agda actually had this feature. Too many ways to create functions \u00b6 Most programming languages offers the flexibility to create functions using different construct such as : free functions static class method instance method constructor Although it might seems good, it actually creates inconsistencies, which is against Human-Computer Interaction principles 8 9 . In layman term, the programming languages will become less user-friendly. For example, in Javascript: // To convert Integer to String ( 123 ). toString () // To conver String to Integer? \"123\" . toInteger () // <- Oops, this is wrong // The correct way is: parseInt ( \"123\" ) // <- WTF?! Such inconsistencies can increase the learning curve, moreover when we decides to create a new function, we might hesitate, because we are not sure which construct to use. Furthermore, this causes weird looking code: # decoding a JSON data result = json . dumps ( data . encode ()) # is json an object or namespace? # it could be better if it looks like this result = data . encode () . toJson () # OR result = toJson ( encode ( data )) Solution \u00b6 Due to the consequences of having too many ways to create functions, Pineapple only provide one way to create functions, which is using free functions . Conclusion \u00b6 Due to the reasons above, I decided to create a new language called Pineapple to resolve those issues. Glass, R.L., 2001. Frequently forgotten fundamental facts about software engineering. IEEE software, 18(3), pp.112-111. \u21a9 Lientz, B.P., Swanson, E.B. and Tompkins, G.E., 1978. Characteristics of application software maintenance. Communications of the ACM, 21(6), pp.466-471. \u21a9 Pearse, T., and Oman, P., 1995, October. Maintainability measurements on industrial source code maintenance activities. In Software Maintenance, 1995. Proceedings., International Conference on (pp. 295-303). IEEE. \u21a9 Galorath. 2017. Accurately Estimate Your Software Maintenance Costs \u21a9 Martin, R. C., 2009. Clean code: A handbook of agile software craftsmanship. Upper Saddle River, NJ: Prentice-Hall. \u21a9 Gros-Dubois, J. 2017. Statically typed vs dynamically typed languages \u21a9 React.js Conf 2015. Immutable Data and React \u21a9 Shneiderman, B., 2010. Designing the user interface: strategies for effective human-computer interaction. Pearson Education India. \u21a9 Schneiderman's Eight Golden Rules of Interface Design \u21a9","title":"Motivation"},{"location":"001-motivation/#introduction","text":"In any software project, the most expensive cost is actually not the development, but the maintenance, with some citing as high as 75% of the resources actually went into maintenance. 1 2 3 4 According to the author of Clean Code, Uncle Bob, the main reason that causes software maintenance to be expensive is due to poorly written code . 5 Although the main culprit of dirty codes are programmers, I believe that the other reason might be due to the programming language itself. In fact, most programming languages such as Java, Python, Javascript, Ruby, C/C++ and PHP etc. have the following problem: Hard to write clean code. To write clean code in those languages, oftentimes you need to adhere to some military discipline or zen philosophy, or else you might shoot yourself in the foot. So, this is why Pineapple is created, it is here to solve the difficulties in writing clean code . In other words, Pineapple is here to reduce the WTFs from developers.","title":"Introduction"},{"location":"001-motivation/#factors-that-promoted-dirty-code","text":"In summary, the primary factors that promoted dirty code are: Hard to create understandable functions Too many ways to create functions Hard to extend existing classes Dynamic typing Implicit mutability Note Factor 4 and Factor 5 will not be discussed here as they are already discussed thoroughly by others. 6 7","title":"Factors that promoted dirty code"},{"location":"001-motivation/#hard-to-create-understandable-functions","text":"The main reason that prevented programmers to create understandble functions easily is that most programming languages still bares similarity with Assembly Code. # Assembly MOV A , B # Python send ( a , b ) From the code above, we can see that both Assembly and Python does not differ much. They both have the following characteristics: function name comes before arguments (a.k.a. prefix-oriented) arguments position are ambiguous to understand what the function means, one usually have to lookup for its definition In short, it is unnatural. Because we don't speak in such manner. In general, all our instructive sentences have the following structure: <subject> | <verb> | <object> | <preposition> | <object> For example: <subject> | <verb> | <object> | <preposition> | <object> John, | bring | the apple | to | kitchen. There are several ways to emulate the sentence above in programming languages, but none of them are as clear and concise as the English sentence. # procedural bring ( john , apple , kitchen ) # object-oriented john . bring ( apple , kitchen ) # name parameters bring ( person = john , food = apple , destination = kitchen ) That's why sometimes, no matter how much you cook your brain juice, you just can't figure out a name that is good enough for your function.","title":"Hard to create understandable functions"},{"location":"001-motivation/#solution","text":"The solution to this problem is mixfix function . Mixfix means that the name of the function can be separated into many parts. For example: // Pineapple john . bring ( apple to kitchen ) In this case, the names of the function is bring..to . Facts Some programming languages like Smalltalk and Agda actually had this feature.","title":"Solution"},{"location":"001-motivation/#too-many-ways-to-create-functions","text":"Most programming languages offers the flexibility to create functions using different construct such as : free functions static class method instance method constructor Although it might seems good, it actually creates inconsistencies, which is against Human-Computer Interaction principles 8 9 . In layman term, the programming languages will become less user-friendly. For example, in Javascript: // To convert Integer to String ( 123 ). toString () // To conver String to Integer? \"123\" . toInteger () // <- Oops, this is wrong // The correct way is: parseInt ( \"123\" ) // <- WTF?! Such inconsistencies can increase the learning curve, moreover when we decides to create a new function, we might hesitate, because we are not sure which construct to use. Furthermore, this causes weird looking code: # decoding a JSON data result = json . dumps ( data . encode ()) # is json an object or namespace? # it could be better if it looks like this result = data . encode () . toJson () # OR result = toJson ( encode ( data ))","title":"Too many ways to create functions"},{"location":"001-motivation/#solution_1","text":"Due to the consequences of having too many ways to create functions, Pineapple only provide one way to create functions, which is using free functions .","title":"Solution"},{"location":"001-motivation/#conclusion","text":"Due to the reasons above, I decided to create a new language called Pineapple to resolve those issues. Glass, R.L., 2001. Frequently forgotten fundamental facts about software engineering. IEEE software, 18(3), pp.112-111. \u21a9 Lientz, B.P., Swanson, E.B. and Tompkins, G.E., 1978. Characteristics of application software maintenance. Communications of the ACM, 21(6), pp.466-471. \u21a9 Pearse, T., and Oman, P., 1995, October. Maintainability measurements on industrial source code maintenance activities. In Software Maintenance, 1995. Proceedings., International Conference on (pp. 295-303). IEEE. \u21a9 Galorath. 2017. Accurately Estimate Your Software Maintenance Costs \u21a9 Martin, R. C., 2009. Clean code: A handbook of agile software craftsmanship. Upper Saddle River, NJ: Prentice-Hall. \u21a9 Gros-Dubois, J. 2017. Statically typed vs dynamically typed languages \u21a9 React.js Conf 2015. Immutable Data and React \u21a9 Shneiderman, B., 2010. Designing the user interface: strategies for effective human-computer interaction. Pearson Education India. \u21a9 Schneiderman's Eight Golden Rules of Interface Design \u21a9","title":"Conclusion"},{"location":"003-philosophy/","text":"Pineapple's Philosophy \u00b6 The philosophy of Pineapple are (topmost item has highest priority): Maintainability is more important than quick-and-dirty Error message should be clear and beautiful Type safety without typing too much Side effects are bad for health Consistency is mandatory Built-out whenever possible","title":"Pineapple's Philosophy"},{"location":"003-philosophy/#pineapples-philosophy","text":"The philosophy of Pineapple are (topmost item has highest priority): Maintainability is more important than quick-and-dirty Error message should be clear and beautiful Type safety without typing too much Side effects are bad for health Consistency is mandatory Built-out whenever possible","title":"Pineapple's Philosophy"},{"location":"005-download/","text":"Download Pineapple \u00b6 To use Pineapple interpreter, you need to install Node.js V8.11 first. Then, open command prompt, run the following command: npm install --global pineapple-alpha Note For Windows users, you might need to open the command prompt in Administrator mode. For Linux/Mac users, you might need to prefix the command above with sudo . Warning The current version of Pineapple is an alpha release, so it is meant for alpha testers only as it might contain a lot of bugs, and not all features are fully implemented yet. Validation \u00b6 To ensure that you have installed Pineapple successfully. Type the following command in your command prompt or terminal: pine Then, you should see the following: Pineapple 0 .0.X If you do not see something similar to the output above, it means that you had not successfully installed Pineapple, so you might need to retry again. Create a Hello world! program \u00b6 First, create a file called hello.pine . Secondly, open the file in your favourite code editor (for example, Notepad). Thirdly, copy and paste the following code into hello.pine . def . main \"Hello world!\" . show Fourthly, save the file. Lastly, type in the following command in your command prompt or terminal. pine hello.pine Happy hacking :) Read more about Pineapple features .","title":"Download Pineapple"},{"location":"005-download/#download-pineapple","text":"To use Pineapple interpreter, you need to install Node.js V8.11 first. Then, open command prompt, run the following command: npm install --global pineapple-alpha Note For Windows users, you might need to open the command prompt in Administrator mode. For Linux/Mac users, you might need to prefix the command above with sudo . Warning The current version of Pineapple is an alpha release, so it is meant for alpha testers only as it might contain a lot of bugs, and not all features are fully implemented yet.","title":"Download Pineapple"},{"location":"005-download/#validation","text":"To ensure that you have installed Pineapple successfully. Type the following command in your command prompt or terminal: pine Then, you should see the following: Pineapple 0 .0.X If you do not see something similar to the output above, it means that you had not successfully installed Pineapple, so you might need to retry again.","title":"Validation"},{"location":"005-download/#create-a-hello-world-program","text":"First, create a file called hello.pine . Secondly, open the file in your favourite code editor (for example, Notepad). Thirdly, copy and paste the following code into hello.pine . def . main \"Hello world!\" . show Fourthly, save the file. Lastly, type in the following command in your command prompt or terminal. pine hello.pine Happy hacking :) Read more about Pineapple features .","title":"Create a Hello world! program"},{"location":"999-about/","text":"About \u00b6 Pineapple is designed and implemented by Wong Jia Hau. Pineapple is inspired by Haskell, Smalltalk, Python and Javascript.","title":"About"},{"location":"999-about/#about","text":"Pineapple is designed and implemented by Wong Jia Hau. Pineapple is inspired by Haskell, Smalltalk, Python and Javascript.","title":"About"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS Copyright 2018 Wong Jia Hau Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"Features/001-BasicProgram/","text":"A Basic Pineapple Program \u00b6 Every Pineapple program is executed via the ().main method. For example, def () . main 'hello world' . show 'bye' . show Note Indentation(tab) is necessary. If you are using spaces, it must be 4 spaces per tab. Also, by default, the Prelude library will be loaded.","title":"A Basic Pineapple Program"},{"location":"Features/001-BasicProgram/#a-basic-pineapple-program","text":"Every Pineapple program is executed via the ().main method. For example, def () . main 'hello world' . show 'bye' . show Note Indentation(tab) is necessary. If you are using spaces, it must be 4 spaces per tab. Also, by default, the Prelude library will be loaded.","title":"A Basic Pineapple Program"},{"location":"Features/005-ProgramStructure/","text":"Program structure \u00b6 Basically, all Pineapple program are just lists of definitions . The definitions are: Function definition Struct definition Import definition Constants definition Type aliases definition Trait declaration definition Trait implementation definition Enumeration definition Warning Those features that are not ticked means that they are not implemented yet. For example: // function definition def . main \"Hello world\" . show // struct definition def People : name String : age Number // import definition import \"./myFunctions.pine\" // constants definition def pi = 3 . 142 // type aliases definition def Color = Tuple { Int , Int , Int } // trait declaration definition def Equatable { T } def ( this T ) == ( that T ) -> Bool def ( this T ) != ( that T ) -> Bool return not this == that // trait implementation definition def Equatable { Color } def ( this Color ) == ( that Color ) -> Bool return \\ this . ( 0 ) == that . ( 0 ) and \\ this . ( 1 ) == that . ( 1 ) and \\ this . ( 2 ) == that . ( 2 ) // enumeration definition def Color #red #green #blue #yellow","title":"Program structure"},{"location":"Features/005-ProgramStructure/#program-structure","text":"Basically, all Pineapple program are just lists of definitions . The definitions are: Function definition Struct definition Import definition Constants definition Type aliases definition Trait declaration definition Trait implementation definition Enumeration definition Warning Those features that are not ticked means that they are not implemented yet. For example: // function definition def . main \"Hello world\" . show // struct definition def People : name String : age Number // import definition import \"./myFunctions.pine\" // constants definition def pi = 3 . 142 // type aliases definition def Color = Tuple { Int , Int , Int } // trait declaration definition def Equatable { T } def ( this T ) == ( that T ) -> Bool def ( this T ) != ( that T ) -> Bool return not this == that // trait implementation definition def Equatable { Color } def ( this Color ) == ( that Color ) -> Bool return \\ this . ( 0 ) == that . ( 0 ) and \\ this . ( 1 ) == that . ( 1 ) and \\ this . ( 2 ) == that . ( 2 ) // enumeration definition def Color #red #green #blue #yellow","title":"Program structure"},{"location":"Features/007-Keywords/","text":"Keywords \u00b6 The following table depicts the reserved keywords in Pineapple, it means that you cannot use them to named your variables. def import pass let mutable return if elif else for in while Anyway, this table is just reference purpose, you can skip it if you are not interested.","title":"Keywords"},{"location":"Features/007-Keywords/#keywords","text":"The following table depicts the reserved keywords in Pineapple, it means that you cannot use them to named your variables. def import pass let mutable return if elif else for in while Anyway, this table is just reference purpose, you can skip it if you are not interested.","title":"Keywords"},{"location":"Features/010-BasicFunctions/","text":"Functions \u00b6 Introduction \u00b6 All functions in Pineapple are postfix-oriented, meaning that the function names comes after parameter. In general, there are 5 kinds of functions: Name Meaning Nullifunc Function that don't take any parameters. Monofunc Function that only 1 parameters. Bifunc Function that only 2 parameters. Trifunc Function that only 3 parameters. Polyfunc Function that 4 or more parameters. Note Function name are always started with a dot. There are no exceptions. For example: . show Not only that, . is also a valid function name! You cannot separate the parameters using comma. Every function definition must start with a def keyword. By convention, parameters names are usually this , that or the . Nullifunc (0 parameter) \u00b6 Nullifunc is a function that do not need any parameters, for example: // Here's how you define a nullifunc def (). pi -> Number return 3 . 142 // Here's how you call a nullifunc let x = (). pi Note -> Number means that the (). pi function will return a Number type. Tip If you want to declare a function that does not return anything, just don't put the arrow symbol. For example, def (). showMyName // no need to put -> here pass Monofunc (1 parameter) \u00b6 Monofunc is a function that takes only 1 parameter. Note that the parameter must be at front. For example: // here's how you declare a monofunc def ( this Number ). square -> Number return this * this // here's how you call a monofunc let x = 99 .square // you can chain it! let y = 2 .square.square.square Note this is not a keyword, it is just a variable name! Bifunc (2 parameters) \u00b6 Bifunc is a function that takes 2 parameters. Since you cannot separate parameters with comma, the only way is to put the name in the middle. For example: // here's how you define a bifunc def ( this Number ). plus ( that Number ) -> Number return this + that // here's how you call a bifunc let x = 99 .plus ( 99 ). plus ( 22 ) Trifunc (3 parameters) \u00b6 Trifunc is a function that takes 3 parameters. As mentioned before, you cannot separate parameters with comma. So, you should separate them with an identifier. For example, // Here's how you define a trifunc def ( this String ). replace ( old String with new String ) -> String pass // Here's how you call a trifunc let x = \"Hello world\" . replace ( \"world\" with \"baby\" ) Note with is not a keyword, it is a sub function identifier , it means that you can use any word you like as long as it is a single alphabetical word without spaces! Just to make it clear, let see another Trifunc example: // Defining a trifunc def ( this Socket ). send ( message String to portNumber Integer ) pass // Here's how you use it mySocket .send ( \"Hello world\" to 8080 ) In this case, to is the sub function identifier . Why is the sub function identifier necessary? Pineapple enforces this rules so that every function can be understood better. Compare the following functions: // Javascript replace ( \"Hello\" , \"el\" , \"lo\" ) // Hmm, is it replacing \"el\" or \"lo\" ? // Pineapple \"Hello\" . replace ( \"el\" with \"lo\" ) // I am very sure it is replacing \"el\" with \"lo\"! There are at least 2 advantages with it: First, you don't need to write too much documentation about your function, as the name already tells the meaning Secondly, when others read your code, they can understand faster Polyfunc (4 or more parameters) \u00b6 Polyfunc is a function that takes 4 or more parameters. It is similar as Trifunc, but it needs 2 or more sub function identifiers . For example, // Here's how you define a Polyfunc with 4 parameters def ( this String ). replace ( startIndex Integer to endIndex Integer with new String ) -> String pass // Here's how you call it let x = \"Hello world\" . replace ( 0 to 4 with \"Hi\" ) Tips Sometimes, your function might require a lot of parameters. In such case, defining functions like this would be dreadful. So, you should pack those parameters into a single structure. For example, def RequestParam : url String : method String : body String : schema String def ( this Server ). send ( that RequestParam ) pass Example of usage: let param = RequestParam : url = \"192.168.0.0/api/people\" : method = \"POST\" : body = ' { \"name\" : \"Johnny\" , \"age\" : 999 } ' : schema = \"FREE\" myServer .send ( param ) Warning Polyfunc is not implemented yet. Function chaining \u00b6 Sometimes you might want to pass a data through multiple functions. So, instead of using many variables, for example, // Using many variables to store intermediate results def ( this Point ). distanceTo ( that Point ) -> Number let xDistance = this : x - that : x let yDistance = this : y - that : y let xDistanceSquared = xDistance .square let yDistanceSquared = yDistance .square let sum = xDistanceSquared + yDistanceSquared let distance = sum .squareRoot You can use function chaining , as the following, // Using function chaining def ( this Point ). distanceTo ( that Point ) -> Number return (( this : x - that : x ). square + ( this : y - that : y ). square ). squareRoot Multiple line function chaining \u00b6 If you think you cannot fit all the functions you want to call in a single line, you can also use multiple line function chaining, for example, def Color : red Number : green Number : blue Number // multiple line function chaining def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) . and ( this : blue == that : blue ) Warning When using multiple line function chaining(MLFC), indentation is important. The following are examples of invalid MLFC. // Error def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) // Should have one indentation here . and ( this : blue == that : blue ) // Error def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) // Too much indentation here . and ( this : blue == that : blue ) What's the difference of Pineapple function with named parameters? \u00b6 Look at the following example to understand the difference. # Python replace ( target = \"Hello world\" , old = \"lo\" , new = \"wo\" ) // Pineapple \"Hello world\" . replace ( \"lo\" with \"wo\" ) Obviously, the Pineapple's version is much more clearer than Python's version. Moreover, it is also shorter! Actually, the Pineapple's way of defining function is also known as mixfix function, and that's how it is different from named parameters .","title":"Functions"},{"location":"Features/010-BasicFunctions/#functions","text":"","title":"Functions"},{"location":"Features/010-BasicFunctions/#introduction","text":"All functions in Pineapple are postfix-oriented, meaning that the function names comes after parameter. In general, there are 5 kinds of functions: Name Meaning Nullifunc Function that don't take any parameters. Monofunc Function that only 1 parameters. Bifunc Function that only 2 parameters. Trifunc Function that only 3 parameters. Polyfunc Function that 4 or more parameters. Note Function name are always started with a dot. There are no exceptions. For example: . show Not only that, . is also a valid function name! You cannot separate the parameters using comma. Every function definition must start with a def keyword. By convention, parameters names are usually this , that or the .","title":"Introduction"},{"location":"Features/010-BasicFunctions/#nullifunc-0-parameter","text":"Nullifunc is a function that do not need any parameters, for example: // Here's how you define a nullifunc def (). pi -> Number return 3 . 142 // Here's how you call a nullifunc let x = (). pi Note -> Number means that the (). pi function will return a Number type. Tip If you want to declare a function that does not return anything, just don't put the arrow symbol. For example, def (). showMyName // no need to put -> here pass","title":"Nullifunc (0 parameter)"},{"location":"Features/010-BasicFunctions/#monofunc-1-parameter","text":"Monofunc is a function that takes only 1 parameter. Note that the parameter must be at front. For example: // here's how you declare a monofunc def ( this Number ). square -> Number return this * this // here's how you call a monofunc let x = 99 .square // you can chain it! let y = 2 .square.square.square Note this is not a keyword, it is just a variable name!","title":"Monofunc (1 parameter)"},{"location":"Features/010-BasicFunctions/#bifunc-2-parameters","text":"Bifunc is a function that takes 2 parameters. Since you cannot separate parameters with comma, the only way is to put the name in the middle. For example: // here's how you define a bifunc def ( this Number ). plus ( that Number ) -> Number return this + that // here's how you call a bifunc let x = 99 .plus ( 99 ). plus ( 22 )","title":"Bifunc (2 parameters)"},{"location":"Features/010-BasicFunctions/#trifunc-3-parameters","text":"Trifunc is a function that takes 3 parameters. As mentioned before, you cannot separate parameters with comma. So, you should separate them with an identifier. For example, // Here's how you define a trifunc def ( this String ). replace ( old String with new String ) -> String pass // Here's how you call a trifunc let x = \"Hello world\" . replace ( \"world\" with \"baby\" ) Note with is not a keyword, it is a sub function identifier , it means that you can use any word you like as long as it is a single alphabetical word without spaces! Just to make it clear, let see another Trifunc example: // Defining a trifunc def ( this Socket ). send ( message String to portNumber Integer ) pass // Here's how you use it mySocket .send ( \"Hello world\" to 8080 ) In this case, to is the sub function identifier . Why is the sub function identifier necessary? Pineapple enforces this rules so that every function can be understood better. Compare the following functions: // Javascript replace ( \"Hello\" , \"el\" , \"lo\" ) // Hmm, is it replacing \"el\" or \"lo\" ? // Pineapple \"Hello\" . replace ( \"el\" with \"lo\" ) // I am very sure it is replacing \"el\" with \"lo\"! There are at least 2 advantages with it: First, you don't need to write too much documentation about your function, as the name already tells the meaning Secondly, when others read your code, they can understand faster","title":"Trifunc (3 parameters)"},{"location":"Features/010-BasicFunctions/#polyfunc-4-or-more-parameters","text":"Polyfunc is a function that takes 4 or more parameters. It is similar as Trifunc, but it needs 2 or more sub function identifiers . For example, // Here's how you define a Polyfunc with 4 parameters def ( this String ). replace ( startIndex Integer to endIndex Integer with new String ) -> String pass // Here's how you call it let x = \"Hello world\" . replace ( 0 to 4 with \"Hi\" ) Tips Sometimes, your function might require a lot of parameters. In such case, defining functions like this would be dreadful. So, you should pack those parameters into a single structure. For example, def RequestParam : url String : method String : body String : schema String def ( this Server ). send ( that RequestParam ) pass Example of usage: let param = RequestParam : url = \"192.168.0.0/api/people\" : method = \"POST\" : body = ' { \"name\" : \"Johnny\" , \"age\" : 999 } ' : schema = \"FREE\" myServer .send ( param ) Warning Polyfunc is not implemented yet.","title":"Polyfunc (4 or more parameters)"},{"location":"Features/010-BasicFunctions/#function-chaining","text":"Sometimes you might want to pass a data through multiple functions. So, instead of using many variables, for example, // Using many variables to store intermediate results def ( this Point ). distanceTo ( that Point ) -> Number let xDistance = this : x - that : x let yDistance = this : y - that : y let xDistanceSquared = xDistance .square let yDistanceSquared = yDistance .square let sum = xDistanceSquared + yDistanceSquared let distance = sum .squareRoot You can use function chaining , as the following, // Using function chaining def ( this Point ). distanceTo ( that Point ) -> Number return (( this : x - that : x ). square + ( this : y - that : y ). square ). squareRoot","title":"Function chaining"},{"location":"Features/010-BasicFunctions/#multiple-line-function-chaining","text":"If you think you cannot fit all the functions you want to call in a single line, you can also use multiple line function chaining, for example, def Color : red Number : green Number : blue Number // multiple line function chaining def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) . and ( this : blue == that : blue ) Warning When using multiple line function chaining(MLFC), indentation is important. The following are examples of invalid MLFC. // Error def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) // Should have one indentation here . and ( this : blue == that : blue ) // Error def ( this Color ) == ( that Color ) -> Boolean return ( this : red == that : red ) . and ( this : green == that : green ) // Too much indentation here . and ( this : blue == that : blue )","title":"Multiple line function chaining"},{"location":"Features/010-BasicFunctions/#whats-the-difference-of-pineapple-function-with-named-parameters","text":"Look at the following example to understand the difference. # Python replace ( target = \"Hello world\" , old = \"lo\" , new = \"wo\" ) // Pineapple \"Hello world\" . replace ( \"lo\" with \"wo\" ) Obviously, the Pineapple's version is much more clearer than Python's version. Moreover, it is also shorter! Actually, the Pineapple's way of defining function is also known as mixfix function, and that's how it is different from named parameters .","title":"What's the difference of Pineapple function with named parameters?"},{"location":"Features/013-Operators/","text":"Operators \u00b6 Introduction \u00b6 Unlike most programming languages, Pineapple has only a few built-in operators: Name Symbol Usage Assignment operator = For assigning value to variables Arrow operator -> To specify the return type of a function Comma , To separate elements in a list Question mark ? To make a type nilable/nullable If you notice carefully, not even plus and minus are built-in operators, because you can define them! Fun Fact In Pineapple, operators are just functions that looks special. In Pineapple, you can define two kinds of operator functions: Prefix unary operator Infix binary operator The custom operator can be any symbols on the keyboard except for the built-in operators and brackets. Not only that, it can have variable length. For examples, see the following table. Operator Valid? Reason + Yes - -- Yes - .. Yes - @ Yes - !@# Yes - = No This is a built-in operator . No This is a function name ( See here ) $ $ No Cannot have spaces Prefix unary operator \u00b6 Prefix means in front , unary means single . So, a prefix unary operator is an operator that will be placed in front of a single argument. The code below is an example of defining a prefix minus operator . // Here's how you declare a prefix unary operator function def - ( this Number ) -> Number pass // Here's how you use it let x = - 12 Note pass means that the implementation of the function is temporarily passed. You can think of it as throwing NotImplementedException . pass is used here because the main point here is about how to declare operator function, not about its internal details. How it works? The code above will actually be translated into the following code(although not exactly): // JavaScript let x = minus ( 12 ); Infix binary operator \u00b6 Infix means in between , binary means two . So, an infix binary operator is an operator that will be place in between two arguments. The code below is an example of defining an infix exponent operator . // Here's how you define an infix binary operator def ( this Integer ) ^ ( that Integer ) -> List { Number } pass // Here's how you use it let x = 2 ^ 3 x .show // 8 Tip Infix binary operator is chainable, it means that the following code is valid in Pineapple. let x = 23 + 99 + 100 // No error! Precedence \u00b6 The precedence rule in Pineapple is rather simplistic: Constructs Precendence level (larger means higher) Bracketized expression 3 Named functions 2 Operator functions 1 Keywords 0 When both constructs with the same precedence appear at the same time, the most left one will be computed first . For example, let x = 1 + 1 * 0 // Result is 0, because 1 + 1 will be computed first let y = 2 + 4 .square // Result is 18, because 4.square is computed first Because of this, you don't have to memorize all those operator precedence rules anymore!","title":"Operators"},{"location":"Features/013-Operators/#operators","text":"","title":"Operators"},{"location":"Features/013-Operators/#introduction","text":"Unlike most programming languages, Pineapple has only a few built-in operators: Name Symbol Usage Assignment operator = For assigning value to variables Arrow operator -> To specify the return type of a function Comma , To separate elements in a list Question mark ? To make a type nilable/nullable If you notice carefully, not even plus and minus are built-in operators, because you can define them! Fun Fact In Pineapple, operators are just functions that looks special. In Pineapple, you can define two kinds of operator functions: Prefix unary operator Infix binary operator The custom operator can be any symbols on the keyboard except for the built-in operators and brackets. Not only that, it can have variable length. For examples, see the following table. Operator Valid? Reason + Yes - -- Yes - .. Yes - @ Yes - !@# Yes - = No This is a built-in operator . No This is a function name ( See here ) $ $ No Cannot have spaces","title":"Introduction"},{"location":"Features/013-Operators/#prefix-unary-operator","text":"Prefix means in front , unary means single . So, a prefix unary operator is an operator that will be placed in front of a single argument. The code below is an example of defining a prefix minus operator . // Here's how you declare a prefix unary operator function def - ( this Number ) -> Number pass // Here's how you use it let x = - 12 Note pass means that the implementation of the function is temporarily passed. You can think of it as throwing NotImplementedException . pass is used here because the main point here is about how to declare operator function, not about its internal details. How it works? The code above will actually be translated into the following code(although not exactly): // JavaScript let x = minus ( 12 );","title":"Prefix unary operator"},{"location":"Features/013-Operators/#infix-binary-operator","text":"Infix means in between , binary means two . So, an infix binary operator is an operator that will be place in between two arguments. The code below is an example of defining an infix exponent operator . // Here's how you define an infix binary operator def ( this Integer ) ^ ( that Integer ) -> List { Number } pass // Here's how you use it let x = 2 ^ 3 x .show // 8 Tip Infix binary operator is chainable, it means that the following code is valid in Pineapple. let x = 23 + 99 + 100 // No error!","title":"Infix binary operator"},{"location":"Features/013-Operators/#precedence","text":"The precedence rule in Pineapple is rather simplistic: Constructs Precendence level (larger means higher) Bracketized expression 3 Named functions 2 Operator functions 1 Keywords 0 When both constructs with the same precedence appear at the same time, the most left one will be computed first . For example, let x = 1 + 1 * 0 // Result is 0, because 1 + 1 will be computed first let y = 2 + 4 .square // Result is 18, because 4.square is computed first Because of this, you don't have to memorize all those operator precedence rules anymore!","title":"Precedence"},{"location":"Features/015-Types/","text":"Built-in types \u00b6 Introduction \u00b6 Pineapple has special support for the following types: Boolean Nil (also known as null) Number and Integer String List (also known as array) Tuple (also known as array) Table (also known as Dictionary or HashMap) Boolean \u00b6 Boolean types in Pineapple can be declared using #true and #false . let isHappy = #true let isSad = #false Boolean type is necessary for using control statements such as if-else or while loop. For example, let isMad = #true if isMad \"Oh my goodness\" . show else \"Thank goodness\" . show Nil \u00b6 Nil type is useful when you are not sure what to assign for a variable. let car = #nil // This means that you dont have a car Note By default, you cannot assign #nil to any variable. Check out Variables for more information. Number and Integer \u00b6 let x = 123 // Will be inferred as Integer let y = 123 . 4 // Will be inferred as Number Info Integer is any number that do not contains decimal values. It is especially useful for counting things, for example numberOfFruits should be Integer instead of Number. String \u00b6 In Pineapple, strings are enquoted using double quotes. let message = \"Hello world\" String interpolation \u00b6 You can also interpolate expressions into string using $() . let fruit = \"Pineapple\" let howMany = 5 + 9 let message = \"I like to eat $( fruit ) every $( howMany .toString ) days\" message .show // I like to eat Pineapple 5 days Note Every interpolated expression must have type of String, if not the Pineapple compiler will complain about it. For example, let x = 23 . 4 let message = \"My number is $( x ) \" // Error, `x` should be String, but it is Number To prevent such problem, you have to use the . toString function. Warning Interpolated expression cannot be raw string. For example, let y = \" $( \"yo\" ) \" // Syntax error List \u00b6 List are useful for storing more than one elements. To create a list in Pineapple, you need to use square brackets [ ] and comma , . // Create list of integers let xs = [ 1 , 2 , 3 , 4 ] // You can pass in any expression as element let x = 99 let numbers = [. pi , 3 + 3 , 7 .square , x ] List in Pineapple are homogeneous, it means that all elements within a list must be the same type. For example, let x = [ 1 , \"2\" ] // Error, the second element should be Integer Warning You cannot create an empty list by using [] . Instead you need to use the List constructor. let xs = [] // error let ys = List { Integer } // No error Multiline List \u00b6 Sometimes your list might contains too many elements to be fit in a single line. In such situation you will need to use multiline list. For example, let fruits = o \"Apple\" o \"Banana\" o \"Pineapple\" o \"Durian\" o \"Hello\" Note The indentation is necessary. So, the following is invalid in Pineapple: let fruits = o \"Apple\" o \"Banana\" // Error Reminder Since o is used as list bullet in Pineapple, you cannot named a variable as o . Table \u00b6 Table is also known as Dictionary or HashMap. It is useful when you need to store a list of key-value data. For example, let say you want to store phone numbers: // note that the indentation is necessary let phoneNumbers = \"john\" = \"0123456\" \"babe\" = \"3333222\" \"wong\" = \"3212344\" \"lee\" = \"9843056\" phoneNumbers . ( \"john\" ). show // \"0123456\" Empty table \u00b6 To create an empty table, use the Table constructor. // key , value let phoneNumbers = Table { String , String }","title":"Built-in types"},{"location":"Features/015-Types/#built-in-types","text":"","title":"Built-in types"},{"location":"Features/015-Types/#introduction","text":"Pineapple has special support for the following types: Boolean Nil (also known as null) Number and Integer String List (also known as array) Tuple (also known as array) Table (also known as Dictionary or HashMap)","title":"Introduction"},{"location":"Features/015-Types/#boolean","text":"Boolean types in Pineapple can be declared using #true and #false . let isHappy = #true let isSad = #false Boolean type is necessary for using control statements such as if-else or while loop. For example, let isMad = #true if isMad \"Oh my goodness\" . show else \"Thank goodness\" . show","title":"Boolean"},{"location":"Features/015-Types/#nil","text":"Nil type is useful when you are not sure what to assign for a variable. let car = #nil // This means that you dont have a car Note By default, you cannot assign #nil to any variable. Check out Variables for more information.","title":"Nil"},{"location":"Features/015-Types/#number-and-integer","text":"let x = 123 // Will be inferred as Integer let y = 123 . 4 // Will be inferred as Number Info Integer is any number that do not contains decimal values. It is especially useful for counting things, for example numberOfFruits should be Integer instead of Number.","title":"Number and Integer"},{"location":"Features/015-Types/#string","text":"In Pineapple, strings are enquoted using double quotes. let message = \"Hello world\"","title":"String"},{"location":"Features/015-Types/#string-interpolation","text":"You can also interpolate expressions into string using $() . let fruit = \"Pineapple\" let howMany = 5 + 9 let message = \"I like to eat $( fruit ) every $( howMany .toString ) days\" message .show // I like to eat Pineapple 5 days Note Every interpolated expression must have type of String, if not the Pineapple compiler will complain about it. For example, let x = 23 . 4 let message = \"My number is $( x ) \" // Error, `x` should be String, but it is Number To prevent such problem, you have to use the . toString function. Warning Interpolated expression cannot be raw string. For example, let y = \" $( \"yo\" ) \" // Syntax error","title":"String interpolation"},{"location":"Features/015-Types/#list","text":"List are useful for storing more than one elements. To create a list in Pineapple, you need to use square brackets [ ] and comma , . // Create list of integers let xs = [ 1 , 2 , 3 , 4 ] // You can pass in any expression as element let x = 99 let numbers = [. pi , 3 + 3 , 7 .square , x ] List in Pineapple are homogeneous, it means that all elements within a list must be the same type. For example, let x = [ 1 , \"2\" ] // Error, the second element should be Integer Warning You cannot create an empty list by using [] . Instead you need to use the List constructor. let xs = [] // error let ys = List { Integer } // No error","title":"List"},{"location":"Features/015-Types/#multiline-list","text":"Sometimes your list might contains too many elements to be fit in a single line. In such situation you will need to use multiline list. For example, let fruits = o \"Apple\" o \"Banana\" o \"Pineapple\" o \"Durian\" o \"Hello\" Note The indentation is necessary. So, the following is invalid in Pineapple: let fruits = o \"Apple\" o \"Banana\" // Error Reminder Since o is used as list bullet in Pineapple, you cannot named a variable as o .","title":"Multiline List"},{"location":"Features/015-Types/#table","text":"Table is also known as Dictionary or HashMap. It is useful when you need to store a list of key-value data. For example, let say you want to store phone numbers: // note that the indentation is necessary let phoneNumbers = \"john\" = \"0123456\" \"babe\" = \"3333222\" \"wong\" = \"3212344\" \"lee\" = \"9843056\" phoneNumbers . ( \"john\" ). show // \"0123456\"","title":"Table"},{"location":"Features/015-Types/#empty-table","text":"To create an empty table, use the Table constructor. // key , value let phoneNumbers = Table { String , String }","title":"Empty table"},{"location":"Features/020-Variables/","text":"Variables \u00b6 To create a variable, you need to use the let keyword: let myVariable = \"Hello World!\" Note Every variable in Pineapple must start with lowercase letter and cannot contain any spaces or underscore. The following are invalid variable names: let Message = \"Yo\" // Invalid, cannot start with uppercase letter let my name = \"Wong\" // Invalid, cannot contain spaces let my_ pet = \"Cat\" // Invalid, cannot contain underscore Type inference \u00b6 The type of each variables are resolved automatically by the Pineapple compiler, so you don't need to provide any type annotation. For example: let x = \"yo\" // x has type of String let y = 0 // y has type of Integer let z = [ 1 , 2 , 3 ] // z has type of List{Integer} Although unnessecary, it is also possible to annotate variables with type manually: let x String = \"yo\" Default immutability \u00b6 By default, all variables in Pineapple are immutable , it means that you cannot assign a new value to it after you declare it. let count = 0 count = 1 // Error Info Mutable means changeable . Immutable means not changeable . If you wish to make a variable mutable, you need to use the mutable keyword. let x mutable = 0 x = 1 // No error Tip This feature is implemented on purpose to discourage programmers from mutating variables all the time. So, instead of creating one variables and change it all the time, create as many variables as you want! Default non-nullablility \u00b6 By default, you cannot assign #nil to a mutable variable. let x mutable = 0 x = #nil // Error What is nil? Nil is actually same as null, just that nil is easier to type, so nil is adapted in Pineapple. If you want to assign #nil to a variable, you need to declare it explicitly by using nilable types (which is to add a question mark behind the type name). let x Int ? mutable = 0 x = #nil // No error Pass by value \u00b6 When you try to assign the value of one variable to another variable, the value is copied, instead of copying its reference. For example, let john = People : name = \"John\" : age = 99 let newJohn = john // copy john to newJohn newJohn : name = \"Johnny Bravo\" john : name . show // Still \"John\" Why? This feature is to prevent programmer from facing crazy bugs caused by pass-by-reference. Optimization (implementing) \u00b6 Of course, pass-by-value is expensive, thus it might slows down the program performance. Fortunately, the Pineapple compiler will use pass-by-reference whenever possible. For example: let x = 10 let y = x // x's value is pass-by-reference since it is not used afterwards y . show Another example: let x = 10 let y = x // x's value is pass-by-value, since it is still in used after this line x . show y . show","title":"Variables"},{"location":"Features/020-Variables/#variables","text":"To create a variable, you need to use the let keyword: let myVariable = \"Hello World!\" Note Every variable in Pineapple must start with lowercase letter and cannot contain any spaces or underscore. The following are invalid variable names: let Message = \"Yo\" // Invalid, cannot start with uppercase letter let my name = \"Wong\" // Invalid, cannot contain spaces let my_ pet = \"Cat\" // Invalid, cannot contain underscore","title":"Variables"},{"location":"Features/020-Variables/#type-inference","text":"The type of each variables are resolved automatically by the Pineapple compiler, so you don't need to provide any type annotation. For example: let x = \"yo\" // x has type of String let y = 0 // y has type of Integer let z = [ 1 , 2 , 3 ] // z has type of List{Integer} Although unnessecary, it is also possible to annotate variables with type manually: let x String = \"yo\"","title":"Type inference"},{"location":"Features/020-Variables/#default-immutability","text":"By default, all variables in Pineapple are immutable , it means that you cannot assign a new value to it after you declare it. let count = 0 count = 1 // Error Info Mutable means changeable . Immutable means not changeable . If you wish to make a variable mutable, you need to use the mutable keyword. let x mutable = 0 x = 1 // No error Tip This feature is implemented on purpose to discourage programmers from mutating variables all the time. So, instead of creating one variables and change it all the time, create as many variables as you want!","title":"Default immutability"},{"location":"Features/020-Variables/#default-non-nullablility","text":"By default, you cannot assign #nil to a mutable variable. let x mutable = 0 x = #nil // Error What is nil? Nil is actually same as null, just that nil is easier to type, so nil is adapted in Pineapple. If you want to assign #nil to a variable, you need to declare it explicitly by using nilable types (which is to add a question mark behind the type name). let x Int ? mutable = 0 x = #nil // No error","title":"Default non-nullablility"},{"location":"Features/020-Variables/#pass-by-value","text":"When you try to assign the value of one variable to another variable, the value is copied, instead of copying its reference. For example, let john = People : name = \"John\" : age = 99 let newJohn = john // copy john to newJohn newJohn : name = \"Johnny Bravo\" john : name . show // Still \"John\" Why? This feature is to prevent programmer from facing crazy bugs caused by pass-by-reference.","title":"Pass by value"},{"location":"Features/020-Variables/#optimization-implementing","text":"Of course, pass-by-value is expensive, thus it might slows down the program performance. Fortunately, the Pineapple compiler will use pass-by-reference whenever possible. For example: let x = 10 let y = x // x's value is pass-by-reference since it is not used afterwards y . show Another example: let x = 10 let y = x // x's value is pass-by-value, since it is still in used after this line x . show y . show","title":"Optimization (implementing)"},{"location":"Features/025-ControlFlowStatements/","text":"Control Flow Statements \u00b6 Basically, you can control the flow of your Pineapple code with any of the following: if , elif and else for loop while loop break , continue or return If-elif-else statements \u00b6 Similar to Python, all you need is indentation (tab), you don't need those curly brackets. For example: if he .isCraz y you .callAmbulanc e elif he .isInDanger you .goHelp ( he ) else you .doNothin g Note Every test expression must have type of Boolean. Tips . isCrazy and other similar construct are just functions . Test expression chaining \u00b6 Sometimes, a single test expression is not enough to express what you really wanted. In such situation, you can use the following functions: . and . or . not For example: if he .isYoun g .an d ( he .isNaught y ) \"He is a kid\" . show elif sky .isBlue.or ( air .isFres h ) \"I am happy!\" . show elif current .isLunchTim e .no t \"Continue working . . .\" . show For statements \u00b6 For statements is used to iterate over a list. For example: for x in [ 1 , 2 , 3 , 4 ] x .show While loop \u00b6 While loop is use to loop some code until certain condition is met. while not file .atEO F file .readline.show","title":"Control Flow Statements"},{"location":"Features/025-ControlFlowStatements/#control-flow-statements","text":"Basically, you can control the flow of your Pineapple code with any of the following: if , elif and else for loop while loop break , continue or return","title":"Control Flow Statements"},{"location":"Features/025-ControlFlowStatements/#if-elif-else-statements","text":"Similar to Python, all you need is indentation (tab), you don't need those curly brackets. For example: if he .isCraz y you .callAmbulanc e elif he .isInDanger you .goHelp ( he ) else you .doNothin g Note Every test expression must have type of Boolean. Tips . isCrazy and other similar construct are just functions .","title":"If-elif-else statements"},{"location":"Features/025-ControlFlowStatements/#test-expression-chaining","text":"Sometimes, a single test expression is not enough to express what you really wanted. In such situation, you can use the following functions: . and . or . not For example: if he .isYoun g .an d ( he .isNaught y ) \"He is a kid\" . show elif sky .isBlue.or ( air .isFres h ) \"I am happy!\" . show elif current .isLunchTim e .no t \"Continue working . . .\" . show","title":"Test expression chaining"},{"location":"Features/025-ControlFlowStatements/#for-statements","text":"For statements is used to iterate over a list. For example: for x in [ 1 , 2 , 3 , 4 ] x .show","title":"For statements"},{"location":"Features/025-ControlFlowStatements/#while-loop","text":"While loop is use to loop some code until certain condition is met. while not file .atEO F file .readline.show","title":"While loop"},{"location":"Features/030-Struct/","text":"Struct \u00b6 Introduction \u00b6 Struct type is a collection of fields, it allows you to give more meaning to your data. In layman terms, you can imagine struct as mould. To create a structure in Pineapple, you have to use the def keyword. Tip In Pineapple, every field name must starts with the colon : symbol. For example, def People : name String : salary Number Note People is the struct name, while : name and : salary is the field name. To create new data from your struct, you have to use the struct name. let john = People : name = \"John\" : salary = 999 Note that the indentation for each field is necessary. To access the field data: let x = john : name Recursive struct \u00b6 You can also create recursive struct which contain fields that points to itself. For example: def People : name String : friend People ? And here's how you create new data from it: let john = People : name = \"Marry\" : friend = People : name = \"Jane\" : friend = People : name = \"Lee\" : friend = ` nil Accessing data: let acquaintance = john : friend : friend Generic struct \u00b6 You can also create generic structure in Pineapple, this feature is important when you need to create custom data structures. Generic struct can help you to prevent some silly type error. For example, // here's how you declare a generic struct def Node { T } : current T : next Node { T } ? // here's how you use it def . main let x = Node { Integer } : current = \"10\" // Error, should be Integer, not String : next = ` nil","title":"Struct"},{"location":"Features/030-Struct/#struct","text":"","title":"Struct"},{"location":"Features/030-Struct/#introduction","text":"Struct type is a collection of fields, it allows you to give more meaning to your data. In layman terms, you can imagine struct as mould. To create a structure in Pineapple, you have to use the def keyword. Tip In Pineapple, every field name must starts with the colon : symbol. For example, def People : name String : salary Number Note People is the struct name, while : name and : salary is the field name. To create new data from your struct, you have to use the struct name. let john = People : name = \"John\" : salary = 999 Note that the indentation for each field is necessary. To access the field data: let x = john : name","title":"Introduction"},{"location":"Features/030-Struct/#recursive-struct","text":"You can also create recursive struct which contain fields that points to itself. For example: def People : name String : friend People ? And here's how you create new data from it: let john = People : name = \"Marry\" : friend = People : name = \"Jane\" : friend = People : name = \"Lee\" : friend = ` nil Accessing data: let acquaintance = john : friend : friend","title":"Recursive struct"},{"location":"Features/030-Struct/#generic-struct","text":"You can also create generic structure in Pineapple, this feature is important when you need to create custom data structures. Generic struct can help you to prevent some silly type error. For example, // here's how you declare a generic struct def Node { T } : current T : next Node { T } ? // here's how you use it def . main let x = Node { Integer } : current = \"10\" // Error, should be Integer, not String : next = ` nil","title":"Generic struct"},{"location":"Features/AdvanceFunctions/","text":"Advance functions \u00b6 Multiple dispatch (Polymorphism) \u00b6 Pineapple supports Multiple Dispatch, it means you can have different function with the same signature as long as they takes different types of parameters. Multiple dispatch allows you to use Polymorphism easily without hassle. For example: // first plus function def ( this Number ) + ( that Number ) -> Number pass // second plus function def ( this String ) + ( that String ) -> String pass // third plus function def ( this List { Number }) + ( that List { Number }) -> List { Number } pass // Example of usage 12 + 13 // will call the first plus function \"12\" + \"13\" // will call the second plus function [ 1 , 2 , 3 ] + [ 4 , 5 , 6 ] // will call the third plus function 12 + \"12\" // error Generic functions \u00b6 Pending","title":"Advance functions"},{"location":"Features/AdvanceFunctions/#advance-functions","text":"","title":"Advance functions"},{"location":"Features/AdvanceFunctions/#multiple-dispatch-polymorphism","text":"Pineapple supports Multiple Dispatch, it means you can have different function with the same signature as long as they takes different types of parameters. Multiple dispatch allows you to use Polymorphism easily without hassle. For example: // first plus function def ( this Number ) + ( that Number ) -> Number pass // second plus function def ( this String ) + ( that String ) -> String pass // third plus function def ( this List { Number }) + ( that List { Number }) -> List { Number } pass // Example of usage 12 + 13 // will call the first plus function \"12\" + \"13\" // will call the second plus function [ 1 , 2 , 3 ] + [ 4 , 5 , 6 ] // will call the third plus function 12 + \"12\" // error","title":"Multiple dispatch (Polymorphism)"},{"location":"Features/AdvanceFunctions/#generic-functions","text":"Pending","title":"Generic functions"},{"location":"Features/Generics/","text":"Generics \u00b6 Generic specialization \u00b6","title":"Generics"},{"location":"Features/Generics/#generics","text":"","title":"Generics"},{"location":"Features/Generics/#generic-specialization","text":"","title":"Generic specialization"},{"location":"Features/JavaScriptBinding/","text":"JavaScript binding \u00b6 Since Pineapple is a function that compiles to Javascript, you can easily use Javascript functions within Pineapple. To create a function that call native JS function, you need to: use the <javascript> tag prepend dollar sign $ to parameters For example: // Example 1 def ( this Any ). show < javascript > console .lo g ( $ this ) < /javascript> // Example 2 def ( this Number ) ^ ( that Number ) -> Number < javascript > Math .po w ( $ this , $ that ) < /javascript> Not only that, it is also possible to use Node's require to import 3 rd party modules. def ( filename String ). open -> String < javascript > const fs = require ( \"fs\" ) return fs .readFileSync ( $ filename ); < /javascript> Binding asynchronous functions \u00b6 To bind to a callback function, you need to use the async keyword. Furthermore, you must return a Promise. For example, def async ( question String ). ask -> String < javascript > const readline = require ( ' readline ' ); const rl = readline .createInterfac e ({ input : process .stdi n , output : process .stdout }); return new Promise (( resolve , reject ) => { rl .question ( $ question , ( message ) => { resolve ( message ); rl .clos e (); }); }) < /javascript> And to use it, you don't need to use async or await keyword, just treat it as a normal function! def . main // no need to annotate `async` here let name = \"What is your name? \" . ask // no need to annotate it with `await` \"Hello $( name ) !\" . show","title":"JavaScript binding"},{"location":"Features/JavaScriptBinding/#javascript-binding","text":"Since Pineapple is a function that compiles to Javascript, you can easily use Javascript functions within Pineapple. To create a function that call native JS function, you need to: use the <javascript> tag prepend dollar sign $ to parameters For example: // Example 1 def ( this Any ). show < javascript > console .lo g ( $ this ) < /javascript> // Example 2 def ( this Number ) ^ ( that Number ) -> Number < javascript > Math .po w ( $ this , $ that ) < /javascript> Not only that, it is also possible to use Node's require to import 3 rd party modules. def ( filename String ). open -> String < javascript > const fs = require ( \"fs\" ) return fs .readFileSync ( $ filename ); < /javascript>","title":"JavaScript binding"},{"location":"Features/JavaScriptBinding/#binding-asynchronous-functions","text":"To bind to a callback function, you need to use the async keyword. Furthermore, you must return a Promise. For example, def async ( question String ). ask -> String < javascript > const readline = require ( ' readline ' ); const rl = readline .createInterfac e ({ input : process .stdi n , output : process .stdout }); return new Promise (( resolve , reject ) => { rl .question ( $ question , ( message ) => { resolve ( message ); rl .clos e (); }); }) < /javascript> And to use it, you don't need to use async or await keyword, just treat it as a normal function! def . main // no need to annotate `async` here let name = \"What is your name? \" . ask // no need to annotate it with `await` \"Hello $( name ) !\" . show","title":"Binding asynchronous functions"},{"location":"Features/Modules/","text":"Module \u00b6 Warning This document is currently a draft, it means it will change anytime. Importing code from other files \u00b6 Suppose the following file structure: - myFoler - math.pine - app.pine // File math.pine def ( this Number ). square -> Number pass def ( this Number ). inverse -> Number pass // File app.pine import \"./math.pine\" def . main let x = 2 .square Every function defined in math.pine is now exposed in app.pine . Importing code from Github \u00b6 You must specify the version. import \"github.com/wongjiahau/yaml/v2.0.0\" Default encapsulation \u00b6 By default, the imported modules of an imported module will not be exposed to the importer. Consider the following scenario // Filename: math.pine def Note If A imported B, and B imported C, the declarations from C will not be exposed in A.","title":"Module"},{"location":"Features/Modules/#module","text":"Warning This document is currently a draft, it means it will change anytime.","title":"Module"},{"location":"Features/Modules/#importing-code-from-other-files","text":"Suppose the following file structure: - myFoler - math.pine - app.pine // File math.pine def ( this Number ). square -> Number pass def ( this Number ). inverse -> Number pass // File app.pine import \"./math.pine\" def . main let x = 2 .square Every function defined in math.pine is now exposed in app.pine .","title":"Importing code from other files"},{"location":"Features/Modules/#importing-code-from-github","text":"You must specify the version. import \"github.com/wongjiahau/yaml/v2.0.0\"","title":"Importing code from Github"},{"location":"Features/Modules/#default-encapsulation","text":"By default, the imported modules of an imported module will not be exposed to the importer. Consider the following scenario // Filename: math.pine def Note If A imported B, and B imported C, the declarations from C will not be exposed in A.","title":"Default encapsulation"},{"location":"Features/StandardLibrary/","text":"Standard Library \u00b6","title":"Standard Library"},{"location":"Features/StandardLibrary/#standard-library","text":"","title":"Standard Library"},{"location":"Features/Traits/","text":"","title":"Traits"}]}