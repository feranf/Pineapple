import { SourceCode } from "./interpret";
import { newBuiltinType } from "./typeTree";
import { GenTypeParamBinding } from "./fillUpTypeInformation";

// Abstract Syntax Tree Node Interfaces
export type InstantiatedTypeParams = TypeExpression[];

export interface SyntaxTree {
    source: SourceCode;
    declarations: Declaration[];
    importedFiles: {[filename: string]: true};
}

export type Declaration
    = FunctionDeclaration
    | ThingDecl
    | ImportDeclaration
    | EnumDecl
    | ExampleDeclaration
    | GroupDeclaration
    | GroupBindingDeclaration
    // TODO: To be implemented soon
    // | InterfaceDeclaration
    // | ImplementionDeclaration
    ;

export interface GroupBindingDeclaration {
    kind: "GroupBindingDeclaration";
    childType: TypeExpression;
    parentType: TypeExpression;
}

export interface GroupDeclaration {
    kind: "GroupDeclaration";
    name: AtomicToken;
    nullable: boolean;
    location: TokenLocation;

    // This property is required by the transpiler (for dynamic dispatching)
    // It is not generated by the parser
    // However, it is to be completed by the static analyzer (i.e. fillUpTypeInfo)
    // It means which functions are tied to this group
    bindingFunctions: FunctionDeclaration[];
}

export interface ExampleDeclaration {
    kind: "ExampleDeclaration";
    description: string | null;
    statements: Statement[];
    location: TokenLocation;
}

export interface FunctionDeclaration {
    kind: "FunctionDeclaration";
    affix: FunctionAffix;
    signature: AtomicToken[];
    returnType: TypeExpression | null;
    parameters: VariableDeclaration[];
    statements: Statement[];
    originFile: string;
    isAsync: boolean;
    typeConstraint ?: TypeConstraint;
    groupBinding ?: GroupBindingStatement;
}

export interface GroupBindingStatement {
    kind: "GroupBindingStatement";
    genTypeParams: AtomicToken[];
    typeBinded: TypeExpression;
}

export interface TypeConstraint {
    kind: "TypeConstraint";
    traitName: AtomicToken;
    genericList: InstantiatedTypeParams;
}

export interface ThingDecl {
    kind: "ThingDecl";
    name: ThingName;
    members: MemberDefinition[];
    location: TokenLocation;
    originFile: string;
}

export interface ThingName {
    identifiers: AtomicToken[];
    genTypeParams: GenTypeParam[];
}

export interface MemberDefinition {
    name: AtomicToken;
    expectedType: TypeExpression;
}

export type Statement
    = AssignmentStatement
    | FunctionCall
    | JavascriptCode
    | ReturnStatement
    | BranchStatement
    | ForStatement
    | WhileStatement
    | PassStatement
    | EnsureStatement
    | ExampleStatement
    ;

export interface ExampleStatement {
    kind: "ExampleStatement";
    left: Expression;
    right: Expression;
    location: TokenLocation;
    originFile: string;
}

export interface EnsureStatement {
    kind: "EnsureStatement";
    expression: Expression;
    location: TokenLocation;
    callingFile: string;
}

export interface ImportDeclaration {
    kind: "ImportDeclaration";
    filename: StringExpression;
    originFile: string;  // originFile means where the current declaration is declared
}

export interface PassStatement {
    kind: "PassStatement";
    location: TokenLocation;
    callingFile: string;
}

export interface WhileStatement {
    kind: "WhileStatement";
    test: Expression;
    body: Statement[];
}

export interface ForStatement {
    kind: "ForStatement";
    iterator: Variable;
    expression: Expression;
    body: Statement[];
}

export interface BranchStatement {
    kind: "BranchStatement";
    test: Expression;
    body: Statement[];
    elseBranch: BranchStatement;
}

export interface ReturnStatement {
    kind: "ReturnStatement";
    expression: Expression;
    location: TokenLocation;
}

export interface AssignmentStatement {
    kind: "AssignmentStatement";
    variable: Variable | VariableDeclaration;
    isDeclaration: boolean;
    expression: Expression;
}

export type TypeExpression
    = UnresolvedType       // e.g. String or List{Number}
    | ResolvedType
    ;

export type ResolvedType
    = GenTypeParam  // e.g. T, T1 or T2
    | VoidType
    | EnumDecl
    | ThingType
    | BuiltinType
    | GroupDeclaration
    ;

export interface BuiltinType {
    kind: "BuiltinType";
    name: BuiltinTypename;
    typeParams: InstantiatedTypeParams;
    nullable: boolean;
    location: TokenLocation;
}
export type BuiltinTypename
    = ":any"
    | ":number"
    | ":integer"
    | ":string"
    | ":date"
    | ":list"
    | ":table"
    | ":thing"
    | ":tuple"
    | ":enum"
    ;
    
// ThingType is things that are instantiated, for example :number:tree
export interface ThingType {
    kind: "ThingType";
    reference: ThingDecl;
    nullable: boolean;
    typeParams: GenTypeParamBinding;
    members: MemberDefinition[];
    location: TokenLocation;
}

export interface EnumDecl {
    kind: "EnumDeclaration";
    name: AtomicToken;
    enums: AtomicToken[];
    location: TokenLocation;
    nullable: boolean;
    originFile: string;
}

export interface EnumExpr {
    kind: "EnumExpression";
    repr: string;
    returnType: EnumDecl;
    location: TokenLocation;
}

export interface VoidType {
    kind: "VoidType";
    name: AtomicToken;
    location: TokenLocation;
    nullable: boolean;
}

export interface UnresolvedType {
    kind: "UnresolvedType";
    name: AtomicToken;
    nullable: boolean;
    location: TokenLocation;
    genTypeParams: Array<UnresolvedType | GenTypeParam>;
}

export interface GenTypeParam {
    kind: "GenTypeParam";
    name: AtomicToken; // "T" | "T1" | "T2";
    nullable: boolean;
    location: TokenLocation;
}

export type Expression
    = FunctionCall
    | StringExpression
    | NumberExpression
    | EnumExpr
    | Variable
    | ThingExpr // Pineapple Object Notation (PON)
    | ThingAccess
    | ThingUpdate
    | ListExpression // a.k.a. Array. To store elements of same type
    | TupleExpression // to store element of different type
    | AnonymousExpression
    | Lambda
    | StringInterpolationExpression
    ;

export interface StringInterpolationExpression {
    kind: "StringInterpolationExpression";
    expressions: Expression[];
    location: TokenLocation;
    returnType: TypeExpression;
}

export interface TupleExpression {
    kind: "TupleExpression";
    elements: Expression[];
    location: TokenLocation;
    returnType: TypeExpression;
}

export interface AnonymousExpression {
    kind: "AnonymousExpression";
    position: 0 | 1 | 2 | 3 | 4 | 5;
    location: TokenLocation;
    returnType: TypeExpression;
}

export interface Lambda {
    kind: "Lambda";
    returnType: TypeExpression;
    location: TokenLocation;
    // placeholders: //TODO: Complete this
}

export type FunctionAffix = "nofix" | "prefix" | "suffix" | "infix" | "mixfix";

export interface FunctionCall {
    kind: "FunctionCall";
    fix: FunctionAffix;
    signature: AtomicToken[];
    parameters: Expression[];
    returnType: TypeExpression;
    location: TokenLocation;
    isAsync: boolean;
    callingFile: string;
}

export interface VariableDeclaration {
    kind: "VariableDeclaration";
    variable: Variable;
    isMutable: boolean;
    typeExpected: TypeExpression; // This info is captured by parser
}

export interface Variable extends AtomicToken {
    kind: "Variable";
    isMutable: boolean;
    returnType: TypeExpression; // This info should be fill in by type checker
}

export interface ThingExpr { // NOTE: Object is also Dictionary/Table
    kind: "ThingExpr";
    constructor: TypeExpression;
    keyValueList: KeyValue[];
    returnType: TypeExpression;
    location: TokenLocation;
}

export function EmptyTable(location: TokenLocation, type: TypeExpression): ThingExpr {
    return {
        kind: "ThingExpr",
        constructor: type,
        keyValueList: [],
        returnType: type,
        location: location
    };
}

export interface KeyValue {
    memberName: AtomicToken;
    expression: Expression;
}

export interface ThingAccess {
    kind: "ThingAccess";
    subject: Expression;
    key: AtomicToken;
    returnType: TypeExpression;
    location: TokenLocation;
}

export interface ThingUpdate {
    kind: "ThingUpdate";
    toBeUpdated: Expression;
    updatedKeyValues: KeyValue[];
    returnType: TypeExpression;
}

export interface ListExpression {
    kind: "List";
    elements: Expression[];
    location: TokenLocation;
    returnType: TypeExpression;
}

export function EmptyList(location: TokenLocation, returnType: TypeExpression): ListExpression {
    return {
        kind: "List",
        elements: [],
        location: location,
        returnType: returnType
    };
}

export interface StringExpression extends AtomicToken {
    kind: "String";
    repr: string;
    returnType: TypeExpression;
}

export function newStringExpression(repr: string, location: TokenLocation): StringExpression {
    return {
        kind: "String",
        repr: repr,
        returnType: newBuiltinType(":string"),
        location: location
    };
}

export interface NumberExpression extends AtomicToken {
    kind: "Number";
    returnType: TypeExpression;
}

export interface JavascriptCode extends AtomicToken {
    kind: "JavascriptCode";
}

export interface AtomicToken {
    repr: string; // shorthand for representation
    location: TokenLocation;
}

export interface TokenLocation {
    first_line: number;
    last_line: number;
    first_column: number;
    last_column: number;
}

export function NullTokenLocation(): TokenLocation {
    return {
        first_column: -1,
        first_line: -1,
        last_column: -1,
        last_line: -1,
    };
}

export function newGenericTypename(placeholder: string): GenTypeParam {
    return {
        kind: "GenTypeParam",
        name: newAtomicToken(placeholder),
        location: NullTokenLocation(),
        nullable: false
    };
}

export function newAtomicToken(repr: string): AtomicToken {
    return {
        repr: repr,
        location: NullTokenLocation()
    };
}
